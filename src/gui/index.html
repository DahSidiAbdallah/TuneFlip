<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TuneFlip</title>
    <style>
      :root {
        --primary-bg: #e6f5d7; /* deeper greenish background */
        --header-bg: #d0f0b7; /* deeper header */
        --card-bg: #fdf6e3; /* warm, but not too bright */
        --border: #ffd600; /* strong yellow border */
        --accent: #43b97f; /* deeper green for buttons */
        --accent-dark: #ff9800; /* strong orange for secondary */
        --accent-yellow: #ffe066; /* bright yellow for highlights */
        --text: #222; /* very dark text for contrast */
        --text-muted: #7c7c5c;
        --badge-bg: #fffbe6;
        --input-bg: #f7fbe7;
      }
      body {
        font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
        margin: 0;
        background: var(--primary-bg);
        color: var(--text);
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
        background: var(--header-bg);
        border-bottom: 2px solid var(--border);
      }
      .brand {
        font-weight: 700;
        color: var(--accent-dark);
        letter-spacing: 1px;
        font-size: 1.5em;
        text-shadow: 0 2px 8px #ffd60033;
      }
      .container {
        padding: 18px;
        max-width: 900px;
        margin: 0 auto;
      }
      .card {
        background: var(--card-bg);
        border: 1.5px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        margin-bottom: 16px;
        box-shadow: 0 2px 12px #ffd60022;
      }
      .row { display: flex; gap: 10px; flex-wrap: wrap; }
  label { display: block; font-size: 12px; color: var(--accent-dark); margin-bottom: 6px; font-weight: 600; }
      input[type=text],input[type=number],select {
        background: var(--input-bg);
        border: 1.5px solid var(--border);
        border-radius: 8px;
        padding: 10px;
        color: var(--text);
        width: 100%;
        font-weight: 500;
      }
      .btn {
        background: var(--accent);
        border: none;
        color: #fff;
        padding: 10px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s, color 0.2s;
        box-shadow: 0 2px 8px #43b97f22;
      }
      .btn.secondary { background: var(--accent-dark); color: #fff; }
      .btn:hover { background: var(--accent-dark); color: #fff; }
      .badge {
        background: var(--accent-yellow);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        color: #b36b00;
        font-weight: 700;
        border: 1px solid #ffd600;
      }
      .small { font-size: 12px; color: #b36b00; }
  progress { width: 100%; height: 10px; accent-color: var(--accent-dark); }
  .file { font-family: ui-monospace,Menlo,Consolas,monospace; font-size: 12px; color: #ff9800; }
      .grid { display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 12px; }
      .row-inline { display: flex; gap: 8px; align-items: flex-end; }
      /* Modes */
      body[data-mode="simple"] .advanced{display:none}
      body[data-mode="advanced"] .simpleOnly{display:none}
    </style>
  </head>
  <body>
    <header>
  <div class="brand">TuneFlip</div>
      <div class="row-inline">
  <!-- Theme switcher removed -->
        <label class="badge" style="background:#111827;border:1px solid #374151">Mode</label>
        <select id="modeSel"><option value="simple" selected>Simple</option><option value="advanced">Advanced</option></select>
      </div>
    </header>
    <div class="container">

      <div id="diag" class="card small" style="display:none"></div>

      <!-- Files -->
      <div class="card">
        <div class="row-inline">
          <button class="btn" id="pickFiles">Select files</button>
          <div id="filesCount" class="badge">0 files</div>
        </div>
        <div id="dropZone" class="small" style="margin-top:8px;border:1px dashed #374151;border-radius:8px;padding:16px;text-align:center">Drop files here</div>
        <div id="files" style="margin-top:8px"></div>
      </div>

      <!-- Simple controls -->
  <div class="card simpleOnly" title="Quick conversion with recommended settings. Use Advanced for more control.">
        <div class="grid">
          <div>
            <label for="outDir" title="Where converted files will be saved. You can browse or type a path.">Output folder</label>
            <div class="row-inline">
              <input type="text" id="outDir" placeholder="out" value="out" />
              <button class="btn secondary" id="pickOut">Browse</button>
            </div>
          </div>
          <div>
            <label for="quality" title="Choose between standard, high, or variable bitrate (VBR) quality. Use Advanced for custom.">Quality</label>
            <select id="quality">
              <option value="std">Standard (192 kbps)</option>
              <option value="high">High (256 kbps)</option>
              <option value="vbr2">Very High (VBR 2)</option>
              <option value="custom">Custom (use Advanced)</option>
            </select>
          </div>
          <div>
            <label for="simpleConcurrency" title="How many files to convert at once. Higher = faster, but uses more CPU.">Parallel conversions</label>
            <input type="number" id="simpleConcurrency" value="4" min="1" />
          </div>
          <div>
            <label for="throttle" title="Throttle conversion speed to reduce system impact.">Resource mode</label>
            <select id="throttle">
              <option value="off">Max speed</option>
              <option value="medium">Balanced</option>
              <option value="low">Low impact</option>
            </select>
          </div>
        </div>
        <div class="row-inline" style="margin-top:10px">
          <button class="btn" id="start">Convert</button>
          <button class="btn secondary" id="saveSettings" title="Save all current settings for next time.">Save settings</button>
          <button class="btn secondary" id="loadSettings" title="Restore your last saved settings.">Load settings</button>
          <div id="summary" class="badge">Ready</div>
        </div>
      </div>

      <!-- Advanced controls -->
      <div class="card advanced" title="Full control over all conversion options.">
        <details id="advanced">
          <summary style="cursor:pointer">Advanced options</summary>
          <div class="grid" style="margin-top:12px">
            <div><label for="bitrate" title="Constant bitrate in kbps. Leave blank to use VBR.">Bitrate (kbps)</label><input type="number" id="bitrate" placeholder="192" /></div>
            <div><label for="vbr" title="Variable bitrate level (0=best, 9=smallest). Leave blank to use CBR.">VBR (0-9)</label><input type="number" id="vbr" min="0" max="9" /></div>
            <div><label for="samplerate" title="Audio sample rate in Hz (e.g. 44100, 48000)">Sample rate (Hz)</label><input type="number" id="samplerate" placeholder="44100" /></div>
            <div><label for="channels" title="Number of audio channels (1=mono, 2=stereo)">Channels</label><input type="number" id="channels" placeholder="2" /></div>
            <div><label for="trim" title="Trim audio: start[-end] in seconds. E.g. 5-65 trims to 1:05.">Trim (start[-end] sec)</label><input type="text" id="trim" placeholder="5-65" /></div>
            <div><label for="concurrency" title="How many files to convert at once.">Concurrency</label><input type="number" id="concurrency" placeholder="4" value="4" /></div>
            <div><label>&nbsp;</label>
              <div class="small">
                <label title="Apply EBU R128 loudness normalization (2-pass)"><input type="checkbox" id="loudnorm" /> Loudness normalize</label><br />
                <label title="Preserve input folder structure in output."><input type="checkbox" id="keepStructure" /> Keep folder structure</label><br />
                <label title="Overwrite existing files in output folder."><input type="checkbox" id="overwrite" /> Overwrite</label><br />
                <label title="Simulate conversion without writing files."><input type="checkbox" id="dryRun" /> Dry run</label>
              </div>
            </div>
            <div>
              <label for="autoMeta" title="Try to detect title, artist, album, and cover from input.">Auto metadata</label>
              <div class="small">
                <label title="Enable automatic detection of metadata."><input type="checkbox" id="autoMeta" checked /> Detect title/artist/album/cover</label><br />
                <label title="Use detected metadata even if manual fields are filled."><input type="checkbox" id="preferDetected" /> Prefer detected over manual</label>
              </div>
            </div>
            <div>
              <label for="template" title="Template for output filenames. Use tokens like {basename}.">Output template</label>
              <div class="row-inline">
                <input type="text" id="template" placeholder="{basename}.mp3" style="flex:1" />
                <select id="tokenSel">
                  <option value="">Insert token…</option>
                  <option value="{basename}">{basename}</option>
                  <option value="{ext}">{ext}</option>
                  <option value="{bitrate}">{bitrate}</option>
                  <option value="{vbr}">{vbr}</option>
                </select>
              </div>
              <small class="file" title="Available tokens for output filenames.">Tokens: {basename} {ext} {bitrate} {vbr}</small>
            </div>
            <div>
              <label for="autoCoverEnabled" title="Extract cover image from video at a specific time.">Auto cover</label>
              <div class="row-inline">
                <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="autoCoverEnabled" /> Enable</label>
                <input type="number" id="autoCoverTime" placeholder="5" title="Time (sec)" />
              </div>
            </div>
            <div><label for="id3Title" title="Set custom title for output files.">ID3: Title</label><input type="text" id="id3Title" /></div>
            <div><label for="id3Artist" title="Set custom artist for output files.">ID3: Artist</label><input type="text" id="id3Artist" /></div>
            <div><label for="id3Album" title="Set custom album for output files.">ID3: Album</label><input type="text" id="id3Album" /></div>
            <div><label for="id3Genre" title="Set custom genre for output files.">ID3: Genre</label><input type="text" id="id3Genre" /></div>
            <div><label for="id3Date" title="Set custom date for output files.">ID3: Date</label><input type="text" id="id3Date" /></div>
            <div><label for="id3Track" title="Set custom track number for output files.">ID3: Track</label><input type="text" id="id3Track" /></div>
            <div><label for="id3Comment" title="Set custom comment for output files.">ID3: Comment</label><input type="text" id="id3Comment" /></div>
            <div><label for="coverPath" title="Path to a custom cover image file.">Cover image</label><input type="text" id="coverPath" placeholder="C:\\path\\cover.jpg" /></div>
            <div>
              <label for="retryAttempts" title="How many times to retry failed conversions.">Retry</label>
              <div class="row-inline">
                <input type="number" id="retryAttempts" placeholder="Retries" value="1" style="width:100px" />
                <input type="number" id="retryDelay" placeholder="Delay ms" value="0" style="width:120px" />
              </div>
            </div>
            <div>
              <label for="coverFrameSec" title="Time in seconds to extract cover frame from video.">Cover frame time (sec)</label>
              <input type="number" id="coverFrameSec" placeholder="5" />
            </div>
            <div>
              <label for="coverFrameRules" title="Regex pattern => time (sec), one per line. Example: ^Live => 60">Cover frame rules</label>
              <div class="small" title="Regex pattern => time (sec), one per line. Example: ^Live => 60">Regex pattern => time (sec), one per line. Example: ^Live => 60</div>
              <textarea id="coverFrameRules" rows="4" style="width:100%; background:#0f131a; color:#e6e6e6; border:1px solid #1f2937; border-radius:8px" placeholder="^Intro => 30"></textarea>
            </div>
          </div>

          <div class="card" style="margin-top:12px">
            <div class="row-inline">
              <strong style="flex:1">Presets</strong>
              <input type="text" id="presetName" placeholder="My preset" style="flex:2" />
              <button class="btn secondary" id="savePreset">Save</button>
              <button class="btn secondary" id="deletePreset">Delete</button>
              <select id="presetSelect" style="flex:2"></select>
              <button class="btn" id="loadPreset">Load</button>
            </div>
          </div>
        </details>
      </div>

  <div class="card">
  <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px">
          <label class="small">Resume queue on next launch</label>
          <input type="checkbox" id="resumeToggle" checked />
          <button class="btn secondary" id="resumeClear">Clear queue</button>
          <div id="resumeInfo" class="small"></div>
        </div>
  <div id="progressList"></div>
      <!-- Advanced Convert Button and Output Preview -->
      <div class="card advanced" style="margin-top:16px">
        <div class="row-inline">
          <button class="btn" id="startAdvanced" title="Convert using advanced options">Convert (Advanced)</button>
          <button class="btn secondary" id="previewOutput" title="Preview output file names before converting">Preview Output</button>
        </div>
        <div id="outputPreview" class="small" style="margin-top:8px;white-space:pre-wrap;"></div>
      </div>
      </div>

    </div>
    <script>
      const $ = (s)=>document.querySelector(s);
      const files = [];
      const list = $('#files');
      const progressList = $('#progressList');
      const logs = [];

      // Toasts
      const toaster = document.createElement('div');
      toaster.style.position='fixed'; toaster.style.bottom='20px'; toaster.style.right='20px'; toaster.style.zIndex='9999';
      document.body.appendChild(toaster);
      function toast(msg) {
        const div = document.createElement('div');
        div.textContent = msg;
        div.style.background = '#fffbe6'; // light yellow for visibility
        div.style.color = '#222'; // dark text for contrast
        div.style.border = '1.5px solid #ffd600';
        div.style.padding = '8px 12px';
        div.style.borderRadius = '8px';
        div.style.marginTop = '8px';
        div.style.boxShadow = '0 2px 8px #ffd60033';
        div.style.fontWeight = '600';
        toaster.appendChild(div);
        setTimeout(() => div.remove(), 3000);
      }

  function updateFiles() { const cnt = files.length; $('#filesCount').textContent = cnt + ' file' + (cnt!==1?'s':''); list.innerHTML = files.map(f => `<div class="file">${f}</div>`).join(''); }

      // Mode & Theme
  // Theme switching removed; will use static color scheme matching logo
      const modeSel = document.getElementById('modeSel');
      function applyMode(v){ document.body.setAttribute('data-mode', v); }
      const savedMode = localStorage.getItem('mode')||'simple'; modeSel.value = savedMode; applyMode(savedMode);
      modeSel.addEventListener('change', (e)=>{ const v = e.target.value; localStorage.setItem('mode', v); applyMode(v); });

      // Drag-and-drop
      const dropZone = document.getElementById('dropZone');
      ;['dragenter','dragover'].forEach(evt => dropZone.addEventListener(evt, (e)=>{ e.preventDefault(); dropZone.style.background='#111827'; }));
      ;['dragleave','drop'].forEach(evt => dropZone.addEventListener(evt, (e)=>{ e.preventDefault(); dropZone.style.background=''; }));
      dropZone.addEventListener('drop', (e)=>{
        const listF = Array.from((e.dataTransfer&&e.dataTransfer.files)||[])
          .map(f=>{
            let p = f.path||f.name;
            try { p = decodeURIComponent(p); } catch {}
            return p;
          })
          .filter(Boolean);
        if (listF.length) {
          // Log raw file paths for debugging
          console.log('[TuneFlip Renderer] Raw dropped paths:', listF);
          files.splice(0, files.length, ...listF);
          updateFiles();
        }
      });

      // File selection (normalize Unicode paths)
      document.getElementById('pickFiles').addEventListener('click', async () => {
        const picked = window.vid2mp3?.selectFiles ? await window.vid2mp3.selectFiles() : await new Promise(resolve=>{ const inp = document.createElement('input'); inp.type='file'; inp.multiple=true; inp.accept='video/*'; inp.onchange = ()=>{ const filesList = Array.from(inp.files||[]); const paths = filesList.map(f=>f.path||f.name); resolve(paths); }; inp.click(); });
        if (picked && picked.length) {
          // Log raw file paths for debugging
          console.log('[TuneFlip Renderer] Raw picked paths:', picked);
          const norm = picked.map(p => {
            try {
              return decodeURIComponent(p);
            } catch { return p; }
          });
          files.splice(0, files.length, ...norm);
          updateFiles();
        }
      });

      // Out dir
      document.getElementById('pickOut').addEventListener('click', async () => {
        const dir = window.vid2mp3?.selectFolder ? await window.vid2mp3.selectFolder() : await new Promise(resolve=>{ const inp = document.createElement('input'); inp.type='file'; inp.setAttribute('webkitdirectory',''); inp.setAttribute('directory',''); inp.onchange = ()=>{ const filesList = Array.from(inp.files||[]); const first = filesList[0]; let out = ''; if (first && first.webkitRelativePath) { const wrp = first.webkitRelativePath; const idx = wrp.indexOf('/'); out = idx>0 ? wrp.slice(0, idx) : wrp; } resolve(out); }; inp.click(); });
        if (dir) $('#outDir').value = dir;
      });

      // Progress rows
      const fileProgress = new Map();
      function ensureRow(input) {
        if (fileProgress.has(input)) return fileProgress.get(input);
        const row = document.createElement('div');
        row.className = 'card';
        row.innerHTML = `<div class="file">${input}</div><progress max="100" value="0"></progress><div class="file status small"></div><pre class="error-detail" style="display:none;white-space:pre-wrap;background:#fffbe6;color:#b36b00;font-size:12px;padding:8px 0 0 0;margin:0"></pre>`;
        progressList.appendChild(row);
        fileProgress.set(input, row);
        return row;
      }

      // IPC progress (if available)
      (window.vid2mp3?.onProgress||function(){ return; })((evt) => {
        if (evt.type === 'start') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = 0;
          r.querySelector('.status').textContent = 'Starting…';
        } else if (evt.type === 'progress') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = Math.round(evt.percent||0);
          r.querySelector('.status').textContent = Math.round(evt.percent||0) + '%';
        } else if (evt.type === 'done') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = evt.ok ? 100 : 0;
          if (evt.ok) {
            r.querySelector('.status').textContent = 'Done';
            r.querySelector('.error-detail').style.display = 'none';
          } else {
            r.querySelector('.status').textContent = 'Failed';
            // Show detailed error if available
            let detail = evt.error || '';
            if (evt.stderr) detail += '\n' + evt.stderr;
            r.querySelector('.error-detail').textContent = detail.trim();
            r.querySelector('.error-detail').style.display = 'block';
          }
        }
        logs.push(evt);
      });

      // Quality presets
      const qualitySel = document.getElementById('quality');
      qualitySel.addEventListener('change', ()=>{ const v = qualitySel.value; if (v==='std') { $('#bitrate').value=192; $('#vbr').value=''; } else if (v==='high') { $('#bitrate').value=256; $('#vbr').value=''; } else if (v==='vbr2') { $('#bitrate').value=''; $('#vbr').value=2; } });

      // Settings helpers
    async function loadSettingsIntoUI() {
  console.log('[TuneFlip Debug] Calling settings.get');
  const s = await (window.vid2mp3?.settings?.get?.() || Promise.resolve({}));
  console.log('[TuneFlip Debug] settings.get result:', s);
      if (s.outDir !== undefined) $('#outDir').value = s.outDir;
      if (s.quality !== undefined) $('#quality').value = s.quality;
      if (s.simpleConcurrency !== undefined) $('#simpleConcurrency').value = s.simpleConcurrency;
      if (s.throttle !== undefined) $('#throttle').value = s.throttle;
      // Advanced (map backend fields to UI fields)
      if (s.bitrateKbps !== undefined) $('#bitrate').value = s.bitrateKbps;
      if (s.vbrLevel !== undefined) $('#vbr').value = s.vbrLevel;
      if (s.sampleRate !== undefined) $('#samplerate').value = s.sampleRate;
      if (s.channels !== undefined) $('#channels').value = s.channels;
      if (s.concurrency !== undefined) $('#concurrency').value = s.concurrency;
      if (s.retry && s.retry.attempts !== undefined) $('#retryAttempts').value = s.retry.attempts;
      if (s.retry && s.retry.delayMs !== undefined) $('#retryDelay').value = s.retry.delayMs;
      if (s.loudnorm !== undefined) $('#loudnorm').checked = !!s.loudnorm;
      if (s.keepStructure !== undefined) $('#keepStructure').checked = !!s.keepStructure;
      if (s.overwrite !== undefined) $('#overwrite').checked = !!s.overwrite;
      if (s.dryRun !== undefined) $('#dryRun').checked = !!s.dryRun;
      if (s.template !== undefined) $('#template').value = s.template;
      if (s.autoMeta !== undefined) $('#autoMeta').checked = !!s.autoMeta;
      if (s.preferDetected !== undefined) $('#preferDetected').checked = !!s.preferDetected;
      if (s.autoCoverEnabled !== undefined) $('#autoCoverEnabled').checked = !!s.autoCoverEnabled;
      if (s.autoCoverTime !== undefined) $('#autoCoverTime').value = s.autoCoverTime;
      if (s.coverFrameSec !== undefined) $('#coverFrameSec').value = s.coverFrameSec;
      if (Array.isArray(s.coverFrameRules)) {
        const lines = s.coverFrameRules.map(r=>`${r.pattern} => ${r.timeSec}`).join('\n');
        document.getElementById('coverFrameRules').value = lines;
      }
      if (s.id3Title !== undefined) $('#id3Title').value = s.id3Title;
      if (s.id3Artist !== undefined) $('#id3Artist').value = s.id3Artist;
      if (s.id3Album !== undefined) $('#id3Album').value = s.id3Album;
      if (s.id3Genre !== undefined) $('#id3Genre').value = s.id3Genre;
      if (s.id3Date !== undefined) $('#id3Date').value = s.id3Date;
      if (s.id3Track !== undefined) $('#id3Track').value = s.id3Track;
      if (s.id3Comment !== undefined) $('#id3Comment').value = s.id3Comment;
      if (s.coverPath !== undefined) $('#coverPath').value = s.coverPath;
    }
      async function saveSettingsFromUI() {
  const data = {
          outDir: $('#outDir').value,
          quality: $('#quality').value,
          simpleConcurrency: parseInt($('#simpleConcurrency').value)||4,
          throttle: $('#throttle').value,
          bitrateKbps: parseInt($('#bitrate')?.value)||undefined,
          vbrLevel: parseInt($('#vbr')?.value)||undefined,
          sampleRate: parseInt($('#samplerate')?.value)||undefined,
          channels: parseInt($('#channels')?.value)||undefined,
          concurrency: parseInt($('#concurrency')?.value)||4,
          retry: {
            attempts: parseInt($('#retryAttempts')?.value)||1,
            delayMs: parseInt($('#retryDelay')?.value)||0
          },
          loudnorm: !!document.getElementById('loudnorm')?.checked,
          keepStructure: !!document.getElementById('keepStructure')?.checked,
          overwrite: !!document.getElementById('overwrite')?.checked,
          dryRun: !!document.getElementById('dryRun')?.checked,
          autoMeta: !!document.getElementById('autoMeta')?.checked,
          preferDetected: !!document.getElementById('preferDetected')?.checked,
          template: $('#template')?.value||'',
          autoCoverEnabled: !!document.getElementById('autoCoverEnabled')?.checked,
          autoCoverTime: parseInt($('#autoCoverTime')?.value)||undefined,
          coverFrameSec: parseInt($('#coverFrameSec')?.value)||undefined,
          coverFrameRules: (document.getElementById('coverFrameRules')?.value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          id3Title: $('#id3Title')?.value||'',
          id3Artist: $('#id3Artist')?.value||'',
          id3Album: $('#id3Album')?.value||'',
          id3Genre: $('#id3Genre')?.value||'',
          id3Date: $('#id3Date')?.value||'',
          id3Track: $('#id3Track')?.value||'',
          id3Comment: $('#id3Comment')?.value||'',
          coverPath: $('#coverPath')?.value||'',
        };
  console.log('[TuneFlip Debug] Calling settings.save with:', data);
  await (window.vid2mp3?.settings?.save?.(data) || Promise.resolve(true));
  await loadSettingsIntoUI(); // reload UI after save
      }
      document.getElementById('saveSettings').addEventListener('click', async () => {
        try {
          await saveSettingsFromUI();
          toast('Settings saved');
        } catch (e) {
          console.error('[TuneFlip Debug] Save settings error:', e);
          toast('Failed to save settings');
        }
      });
      document.getElementById('loadSettings').addEventListener('click', async () => {
        try {
          await loadSettingsIntoUI();
          toast('Settings loaded');
        } catch (e) {
          console.error('[TuneFlip Debug] Load settings error:', e);
          toast('Failed to load settings');
        }
      });

      // --- Preset Management ---
      async function updatePresetList() {
        const presets = await (window.vid2mp3?.presets?.list?.() || Promise.resolve({}));
        const select = document.getElementById('presetSelect');
        select.innerHTML = '';
        for (const name in presets) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        }
      }

      document.getElementById('savePreset').addEventListener('click', async () => {
        const name = document.getElementById('presetName').value.trim();
        if (!name) return toast('Please enter a preset name');
        // Gather current settings into an options object:
        const options = await (window.vid2mp3?.settings?.get?.() || Promise.resolve({}));
        try {
          await window.vid2mp3.presets.save(name, options);
          toast(`Preset "${name}" saved`);
          updatePresetList();
        } catch {
          toast('Failed to save preset');
        }
      });

      document.getElementById('loadPreset').addEventListener('click', async () => {
        const select = document.getElementById('presetSelect');
        const name = select.value;
        if (!name) return toast('Please select a preset');
        try {
          const allPresets = await window.vid2mp3.presets.list();
          const presetOptions = allPresets[name];
          if (presetOptions) {
            // Apply each option to the corresponding field (reusing loadSettingsIntoUI logic):
            if (presetOptions.outDir) $('#outDir').value = presetOptions.outDir;
            if (presetOptions.quality) $('#quality').value = presetOptions.quality;
            if (presetOptions.bitrateKbps) $('#bitrate').value = presetOptions.bitrateKbps;
            if (presetOptions.vbrLevel) $('#vbr').value = presetOptions.vbrLevel;
            if (presetOptions.sampleRate) $('#samplerate').value = presetOptions.sampleRate;
            if (presetOptions.channels) $('#channels').value = presetOptions.channels;
            if (presetOptions.concurrency) $('#concurrency').value = presetOptions.concurrency;
            if (presetOptions.retry && presetOptions.retry.attempts !== undefined) $('#retryAttempts').value = presetOptions.retry.attempts;
            if (presetOptions.retry && presetOptions.retry.delayMs !== undefined) $('#retryDelay').value = presetOptions.retry.delayMs;
            if (presetOptions.loudnorm !== undefined) $('#loudnorm').checked = !!presetOptions.loudnorm;
            if (presetOptions.keepStructure !== undefined) $('#keepStructure').checked = !!presetOptions.keepStructure;
            if (presetOptions.overwrite !== undefined) $('#overwrite').checked = !!presetOptions.overwrite;
            if (presetOptions.dryRun !== undefined) $('#dryRun').checked = !!presetOptions.dryRun;
            if (presetOptions.template) $('#template').value = presetOptions.template;
            if (presetOptions.autoMeta !== undefined) $('#autoMeta').checked = !!presetOptions.autoMeta;
            if (presetOptions.preferDetected !== undefined) $('#preferDetected').checked = !!presetOptions.preferDetected;
            if (presetOptions.autoCoverEnabled !== undefined) $('#autoCoverEnabled').checked = !!presetOptions.autoCoverEnabled;
            if (presetOptions.autoCoverTime !== undefined) $('#autoCoverTime').value = presetOptions.autoCoverTime;
            if (presetOptions.coverFrameSec !== undefined) $('#coverFrameSec').value = presetOptions.coverFrameSec;
            if (Array.isArray(presetOptions.coverFrameRules)) {
              const lines = presetOptions.coverFrameRules.map(r=>`${r.pattern} => ${r.timeSec}`).join('\n');
              document.getElementById('coverFrameRules').value = lines;
            }
            if (presetOptions.id3Title !== undefined) $('#id3Title').value = presetOptions.id3Title;
            if (presetOptions.id3Artist !== undefined) $('#id3Artist').value = presetOptions.id3Artist;
            if (presetOptions.id3Album !== undefined) $('#id3Album').value = presetOptions.id3Album;
            if (presetOptions.id3Genre !== undefined) $('#id3Genre').value = presetOptions.id3Genre;
            if (presetOptions.id3Date !== undefined) $('#id3Date').value = presetOptions.id3Date;
            if (presetOptions.id3Track !== undefined) $('#id3Track').value = presetOptions.id3Track;
            if (presetOptions.id3Comment !== undefined) $('#id3Comment').value = presetOptions.id3Comment;
            if (presetOptions.coverPath !== undefined) $('#coverPath').value = presetOptions.coverPath;
            toast(`Preset "${name}" loaded`);
          }
        } catch {
          toast('Failed to load preset');
        }
      });

      document.getElementById('deletePreset').addEventListener('click', async () => {
        const select = document.getElementById('presetSelect');
        const name = select.value;
        if (!name) return;
        if (!confirm(`Delete preset "${name}"?`)) return;
        try {
          await window.vid2mp3.presets.delete(name);
          toast(`Preset "${name}" deleted`);
          updatePresetList();
        } catch {
          toast('Failed to delete preset');
        }
      });

      // Auto-load on startup
      loadSettingsIntoUI();
      updatePresetList();

      // Resume controls
      async function refreshResumeUI() {
        try {
          const r = await (window.vid2mp3?.resume?.get?.() || Promise.resolve({ enabled: true, queue: { pending: [], done: [], fail: [] }}));
          document.getElementById('resumeToggle').checked = !!r.enabled;
          const q = r.queue||{pending:[],done:[],fail:[]};
          document.getElementById('resumeInfo').textContent = `Queue: ${q.pending.length} pending, ${q.done.length} done, ${q.fail.length} failed`;
        } catch {}
      }
      document.getElementById('resumeToggle').addEventListener('change', async (e)=>{
        try { await (window.vid2mp3?.resume?.set?.(e.target.checked) || Promise.resolve(true)); refreshResumeUI(); } catch {}
      });
      document.getElementById('resumeClear').addEventListener('click', async ()=>{
        try {
          await (window.vid2mp3?.resume?.clear?.() || Promise.resolve(true));
          // Clear progress list and fileProgress map
          progressList.innerHTML = '';
          fileProgress.clear();
          refreshResumeUI();
          toast('Queue cleared');
        } catch {}
      });
      refreshResumeUI();


      // Helper to collect all advanced options from UI
      function getAdvancedOptions() {
        return {
          bitrateKbps: parseInt($('#bitrate')?.value) || undefined,
          vbrLevel: parseInt($('#vbr')?.value) || undefined,
          sampleRate: parseInt($('#samplerate')?.value) || undefined,
          channels: parseInt($('#channels')?.value) || undefined,
          loudnorm: !!document.getElementById('loudnorm')?.checked,
          keepStructure: !!document.getElementById('keepStructure')?.checked,
          overwrite: !!document.getElementById('overwrite')?.checked,
          concurrency: parseInt($('#concurrency')?.value) || 4,
          throttle: $('#throttle').value,
          autoMeta: !!document.getElementById('autoMeta')?.checked,
          preferDetected: !!document.getElementById('preferDetected')?.checked,
          template: $('#template')?.value || '{basename}.mp3',
          autoCover: !!document.getElementById('autoCoverEnabled')?.checked,
          autoCoverTime: parseInt($('#autoCoverTime')?.value) || undefined,
          coverFrameSec: parseFloat(document.getElementById('coverFrameSec')?.value) || undefined,
          coverFrameRules: (document.getElementById('coverFrameRules')?.value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          metadata: {
            title: $('#id3Title')?.value || '',
            artist: $('#id3Artist')?.value || '',
            album: $('#id3Album')?.value || '',
            genre: $('#id3Genre')?.value || '',
            date: $('#id3Date')?.value || '',
            track: $('#id3Track')?.value || '',
            comment: $('#id3Comment')?.value || '',
            coverImagePath: $('#coverPath')?.value || ''
          },
          retry: {
            attempts: parseInt($('#retryAttempts')?.value) || 1,
            delayMs: parseInt($('#retryDelay')?.value) || 0
          }
        };
      }

      // Utility: Check if a file has an audio stream using ffprobe
      async function hasAudioStream(filePath) {
        // Use ffprobe-static and Node.js child_process via a backend IPC if needed
        // For now, try conversion and catch the error, or implement a backend IPC for ffprobe
        // Here, we just skip files that previously failed with 'matches no streams'
        // (A real implementation would use a backend IPC to ffprobe)
        return true; // Placeholder: always true, see backend for real check
      }

      // Patch: Filter out files with no audio stream before conversion (frontend warning only)
      async function filterFilesWithAudio(files) {
        // In a real implementation, call a backend IPC to ffprobe each file
        // For now, just return all files (since we can't run ffprobe in browser)
        // You can implement a backend handler for this if needed
        return files;
      }

      // Simple Convert button
      document.getElementById('start').addEventListener('click', async () => {
        if (!files.length) { alert('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        // Use simple concurrency for simple mode
        const options = getAdvancedOptions();
        options.concurrency = parseInt($('#simpleConcurrency')?.value) || 4;
        // Filter files with audio stream (placeholder, see above)
        const filesWithAudio = await filterFilesWithAudio(files);
        if (!filesWithAudio.length) {
          toast('No files with audio streams found.');
          return;
        }
        document.getElementById('summary').textContent = 'Working…';
        try {
          const { results } = await (window.vid2mp3?.startConvert?.({ inputs: filesWithAudio, outDir, options }) || Promise.resolve({ results: [] }));
          const ok = results.filter(r=>r.ok).length; const fail = results.length - ok;
          if (fail > 0) {
            document.getElementById('summary').textContent = `Done: ${ok} ok, ${fail} failed`;
          } else {
            document.getElementById('summary').textContent = `Done: ${ok} ok, 0 failed`;
          }
        } catch (e) {
          document.getElementById('summary').textContent = 'Failed'; toast('Failed to start: ' + (e && e.message || e));
        }
      });

      // Advanced Convert button
      document.getElementById('startAdvanced').addEventListener('click', async () => {
        if (!files.length) { alert('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        const options = getAdvancedOptions();
        // Filter files with audio stream (placeholder, see above)
        const filesWithAudio = await filterFilesWithAudio(files);
        if (!filesWithAudio.length) {
          toast('No files with audio streams found.');
          return;
        }
        document.getElementById('summary').textContent = 'Working…';
        try {
          const { results } = await (window.vid2mp3?.startConvert?.({ inputs: filesWithAudio, outDir, options }) || Promise.resolve({ results: [] }));
          const ok = results.filter(r=>r.ok).length; const fail = results.length - ok;
          if (fail > 0) {
            document.getElementById('summary').textContent = `Done: ${ok} ok, ${fail} failed`;
          } else {
            document.getElementById('summary').textContent = `Done: ${ok} ok, 0 failed`;
          }
        } catch (e) {
          document.getElementById('summary').textContent = 'Failed'; toast('Failed to start: ' + (e && e.message || e));
        }
      });

      // Preview Output button
      document.getElementById('previewOutput').addEventListener('click', async () => {
        if (!files.length) { toast('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        const options = getAdvancedOptions();
        console.log('[TuneFlip Debug] Calling previewOutput with:', { inputs: files, outDir, options });
        try {
          const preview = await (window.vid2mp3?.previewOutput?.({ inputs: files, outDir, options }) || Promise.resolve([]));
          console.log('[TuneFlip Debug] previewOutput result:', preview);
          document.getElementById('outputPreview').textContent = preview.join('\n');
        } catch (e) {
          console.error('[TuneFlip Debug] Preview output error:', e);
          document.getElementById('outputPreview').textContent = 'Failed to preview: ' + (e && e.message || e);
        }
      });

      // Auto-save on exit
      window.addEventListener('beforeunload', ()=>{ saveSettingsFromUI(); });

      // Diagnostics if preload missing
      if (!window.vid2mp3) { const d = document.getElementById('diag'); d.style.display='block'; d.textContent = 'Preload API not detected. Using fallback pickers.'; }
    </script>
  </body>
</html>

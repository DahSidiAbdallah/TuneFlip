<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TuneFlip</title>
    <style>
      :root {
        --primary-bg: #e6f5d7; /* deeper greenish background */
        --header-bg: #d0f0b7; /* deeper header */
        --card-bg: #fdf6e3; /* warm, but not too bright */
        --border: #ffd600; /* strong yellow border */
        --accent: #43b97f; /* deeper green for buttons */
        --accent-dark: #ff9800; /* strong orange for secondary */
        --accent-yellow: #ffe066; /* bright yellow for highlights */
        --text: #222; /* very dark text for contrast */
        --text-muted: #7c7c5c;
        --badge-bg: #fffbe6;
        --input-bg: #f7fbe7;
      }
      body {
        font-family: system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
        margin: 0;
        background: var(--primary-bg);
        color: var(--text);
      }
      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
        background: var(--header-bg);
        border-bottom: 2px solid var(--border);
      }
      .brand {
        font-weight: 700;
        color: var(--accent-dark);
        letter-spacing: 1px;
        font-size: 1.5em;
        text-shadow: 0 2px 8px #ffd60033;
      }
      .container {
        padding: 18px;
        max-width: 900px;
        margin: 0 auto;
      }
      .card {
        background: var(--card-bg);
        border: 1.5px solid var(--border);
        border-radius: 14px;
        padding: 16px;
        margin-bottom: 16px;
        box-shadow: 0 2px 12px #ffd60022;
      }
      .row { display: flex; gap: 10px; flex-wrap: wrap; }
  label { display: block; font-size: 12px; color: var(--accent-dark); margin-bottom: 6px; font-weight: 600; }
      input[type=text],input[type=number],select {
        background: var(--input-bg);
        border: 1.5px solid var(--border);
        border-radius: 8px;
        padding: 10px;
        color: var(--text);
        width: 100%;
        font-weight: 500;
      }
      .btn {
        background: var(--accent);
        border: none;
        color: #fff;
        padding: 10px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s, color 0.2s;
        box-shadow: 0 2px 8px #43b97f22;
      }
      .btn.secondary { background: var(--accent-dark); color: #fff; }
      .btn:hover { background: var(--accent-dark); color: #fff; }
      .badge {
        background: var(--accent-yellow);
        border-radius: 999px;
        padding: 2px 8px;
        font-size: 12px;
        color: #b36b00;
        font-weight: 700;
        border: 1px solid #ffd600;
      }
      .small { font-size: 12px; color: #b36b00; }
  progress { width: 100%; height: 10px; accent-color: var(--accent-dark); }
  .file { font-family: ui-monospace,Menlo,Consolas,monospace; font-size: 12px; color: #ff9800; }
      .grid { display: grid; grid-template-columns: repeat(auto-fit,minmax(220px,1fr)); gap: 12px; }
      .row-inline { display: flex; gap: 8px; align-items: flex-end; }
      /* Modes */
      body[data-mode="simple"] .advanced{display:none}
      body[data-mode="advanced"] .simpleOnly{display:none}
    </style>
  </head>
  <body>
    <header>
  <div class="brand">TuneFlip</div>
      <div class="row-inline">
  <!-- Theme switcher removed -->
        <label class="badge" style="background:#111827;border:1px solid #374151">Mode</label>
        <select id="modeSel"><option value="simple" selected>Simple</option><option value="advanced">Advanced</option></select>
      </div>
    </header>
    <div class="container">

      <div id="diag" class="card small" style="display:none"></div>

      <!-- Files -->
      <div class="card">
        <div class="row-inline">
          <button class="btn" id="pickFiles">Select files</button>
          <div id="filesCount" class="badge">0 files</div>
          <button class="btn" id="openOutBtn" disabled>Open Output Folder</button>
        </div>
        <div id="dropZone" class="small" tabindex="0" role="button" aria-label="Drop audio or video files and folders here" style="margin-top:8px;border:2px dashed #888;border-radius:10px;padding:24px;text-align:center;transition:background 120ms, border-color 120ms;">Drop files or folders here</div>
        <input id="fileInput" type="file" multiple webkitdirectory style="display:none" />
        <ul id="queueList" class="queue"></ul>
        <div class="queue-actions">
          <button id="pauseBtn" class="btn" disabled>Pause</button>
          <button id="resumeBtn" class="btn" disabled>Resume</button>
          <span id="etaLabel" aria-live="polite"></span>
        </div>
      </div>

      <!-- Simple controls -->
  <div class="card simpleOnly" title="Quick conversion with recommended settings. Use Advanced for more control.">
        <div class="grid">
          <div>
            <label for="outDir" title="Where converted files will be saved. You can browse or type a path.">Output folder</label>
            <div class="row-inline">
              <input type="text" id="outDir" placeholder="out" value="out" />
              <button class="btn secondary" id="pickOut">Browse</button>
            </div>
          </div>
          <div>
            <label for="quality" title="Choose between standard, high, or variable bitrate (VBR) quality. Use Advanced for custom.">Quality</label>
            <select id="quality">
              <option value="std">Standard (192 kbps)</option>
              <option value="high">High (256 kbps)</option>
              <option value="vbr2">Very High (VBR 2)</option>
              <option value="custom">Custom (use Advanced)</option>
            </select>
          </div>
          <div>
            <label for="format">Output format</label>
            <select id="format">
              <option value="mp3" selected>MP3</option>
              <option value="aac">AAC (M4A)</option>
              <option value="ogg">OGG (Vorbis)</option>
              <option value="flac">FLAC</option>
              <option value="opus">Opus</option>
            </select>
          </div>
          <div>
            <label for="simpleConcurrency" title="How many files to convert at once. Higher = faster, but uses more CPU.">Parallel conversions</label>
            <input type="number" id="simpleConcurrency" value="4" min="1" />
          </div>
          <div>
            <label for="throttle" title="Throttle conversion speed to reduce system impact.">Resource mode</label>
            <select id="throttle">
              <option value="off">Max speed</option>
              <option value="medium">Balanced</option>
              <option value="low">Low impact</option>
            </select>
          </div>
        </div>
        <div class="row-inline" style="margin-top:10px">
          <button class="btn" id="start">Convert</button>
          <button class="btn secondary" id="saveSettings" title="Save all current settings for next time.">Save settings</button>
          <button class="btn secondary" id="loadSettings" title="Restore your last saved settings.">Load settings</button>
          <div id="summary" class="badge">Ready</div>
          <button id="openOutDir" class="btn secondary" style="margin-left:12px">Open Output Folder</button>
        </div>
      </div>

      <!-- Advanced controls -->
      <div class="card advanced" title="Full control over all conversion options.">
        <details id="advanced" open>
          <summary style="cursor:pointer">Advanced options</summary>
          <div style="margin-top:12px">
            <details open>
              <summary><strong>Audio Settings</strong></summary>
              <div class="grid">
                <div><label for="bitrate" title="Constant bitrate in kbps. Leave blank to use VBR.">Bitrate (kbps)</label><input type="number" id="bitrate" placeholder="192" /></div>
                <div><label for="vbr" title="Variable bitrate level (0=best, 9=smallest). Leave blank to use CBR.">VBR (0-9)</label><input type="number" id="vbr" min="0" max="9" /></div>
                <div><label for="samplerate" title="Audio sample rate in Hz (e.g. 44100, 48000)">Sample rate (Hz)</label><input type="number" id="samplerate" placeholder="44100" /></div>
                <div><label for="channels" title="Number of audio channels (1=mono, 2=stereo)">Channels</label><input type="number" id="channels" placeholder="2" /></div>
                <div><label for="trim" title="Trim audio: start[-end] in seconds. E.g. 5-65 trims to 1:05.">Trim (start[-end] sec)</label><input type="text" id="trim" placeholder="5-65" /></div>
                <div><label for="simpleConcurrency" title="How many files to convert at once. Higher = faster, but uses more CPU.">Concurrency</label><input type="number" id="simpleConcurrency" value="4" min="1" /></div>
              </div>
            </details>
            <details>
              <summary><strong>Processing Options</strong></summary>
              <div class="grid">
                <div class="small">
                  <label title="Apply EBU R128 loudness normalization (2-pass)"><input type="checkbox" id="loudnorm" /> Loudness normalize</label><br />
                  <label title="Preserve input folder structure in output."><input type="checkbox" id="keepStructure" /> Keep folder structure</label><br />
                  <label title="Overwrite existing files in output folder."><input type="checkbox" id="overwrite" /> Overwrite</label><br />
                  <label title="Simulate conversion without writing files."><input type="checkbox" id="dryRun" /> Dry run</label>
                </div>
                <div>
                  <label for="throttle" title="Throttle conversion speed to reduce system impact.">Resource mode</label>
                  <select id="throttle">
                    <option value="off">Max speed</option>
                    <option value="medium">Balanced</option>
                    <option value="low">Low impact</option>
                  </select>
                </div>
                <div>
                  <label for="retryAttempts" title="How many times to retry failed conversions.">Retry</label>
                  <div class="row-inline">
                    <input type="number" id="retryAttempts" placeholder="Retries" value="1" style="width:100px" />
                    <input type="number" id="retryDelay" placeholder="Delay ms" value="0" style="width:120px" />
                  </div>
                </div>
                <div>
                  <label for="coverFrameSec" title="Time in seconds to extract cover frame from video.">Cover frame time (sec)</label>
                  <input type="number" id="coverFrameSec" placeholder="5" />
                </div>
                <div>
                  <label for="coverFrameRules" title="Regex pattern => time (sec), one per line. Example: ^Live => 60">Cover frame rules</label>
                  <div class="small" title="Regex pattern => time (sec), one per line. Example: ^Live => 60">Regex pattern => time (sec), one per line. Example: ^Live => 60</div>
                  <textarea id="coverFrameRules" rows="4" style="width:100%; background:#0f131a; color:#e6e6e6; border:1px solid #1f2937; border-radius:8px" placeholder="^Intro => 30"></textarea>
                </div>
              </div>
            </details>
            <details>
              <summary><strong>Metadata Tags</strong></summary>
              <div class="grid">
                <div><label for="id3Title" title="Set custom title for output files.">ID3: Title</label><input type="text" id="id3Title" /></div>
                <div><label for="id3Artist" title="Set custom artist for output files.">ID3: Artist</label><input type="text" id="id3Artist" /></div>
                <div><label for="id3Album" title="Set custom album for output files.">ID3: Album</label><input type="text" id="id3Album" /></div>
                <div><label for="id3Genre" title="Set custom genre for output files.">ID3: Genre</label><input type="text" id="id3Genre" /></div>
                <div><label for="id3Date" title="Set custom date for output files.">ID3: Date</label><input type="text" id="id3Date" /></div>
                <div><label for="id3Track" title="Set custom track number for output files.">ID3: Track</label><input type="text" id="id3Track" /></div>
                <div><label for="id3Comment" title="Set custom comment for output files.">ID3: Comment</label><input type="text" id="id3Comment" /></div>
                <div><label for="id3Composer">ID3: Composer</label><input type="text" id="id3Composer" /></div>
                <div><label for="id3Disc">ID3: Disc #</label><input type="text" id="id3Disc" /></div>
                <div><label for="coverPath" title="Path to a custom cover image file.">Cover image</label><input type="text" id="coverPath" placeholder="C:\\path\\cover.jpg" /></div>
                <div>
                  <label for="autoMeta" title="Try to detect title, artist, album, and cover from input.">Auto metadata</label>
                  <div class="small">
                    <label title="Enable automatic detection of metadata."><input type="checkbox" id="autoMeta" checked /> Detect title/artist/album/cover</label><br />
                    <label title="Use detected metadata even if manual fields are filled."><input type="checkbox" id="preferDetected" /> Prefer detected over manual</label>
                  </div>
                </div>
              </div>
            </details>
            <details>
              <summary><strong>Output Template & Cover</strong></summary>
              <div class="grid">
                <div>
                  <label for="template" title="Template for output filenames. Use tokens like {basename}.">Output template</label>
                  <div class="row-inline">
                    <input type="text" id="template" placeholder="{basename}.mp3" style="flex:1" />
                    <select id="tokenSel">
                      <option value="">Insert token…</option>
                      <option value="{basename}">{basename}</option>
                      <option value="{ext}">{ext}</option>
                      <option value="{bitrate}">{bitrate}</option>
                      <option value="{vbr}">{vbr}</option>
                    </select>
                  </div>
                  <small class="file" title="Available tokens for output filenames.">Tokens: {basename} {ext} {bitrate} {vbr}</small>
                </div>
                <div>
                  <label for="formatAdv">Output format</label>
                  <select id="formatAdv">
                    <option value="mp3" selected>MP3</option>
                    <option value="aac">AAC (M4A)</option>
                    <option value="ogg">OGG (Vorbis)</option>
                    <option value="flac">FLAC</option>
                    <option value="opus">Opus</option>
                  </select>
                </div>
                <div>
                  <label for="autoCoverEnabled" title="Extract cover image from video at a specific time.">Auto cover</label>
                  <div class="row-inline">
                    <label style="display:flex;align-items:center;gap:8px"><input type="checkbox" id="autoCoverEnabled" /> Enable</label>
                    <input type="number" id="autoCoverTime" placeholder="5" title="Time (sec)" />
                  </div>
                </div>
              </div>
            </details>
          </div>
        </details>

          <div class="card" style="margin-top:12px">
            <div class="presets-bar row-inline">
              <select id="presetSelect"></select>
              <input id="presetName" placeholder="Preset name" />
              <button id="presetSave">Save</button>
              <button id="presetLoad">Load</button>
              <button id="presetDel">Delete</button>
              <button id="presetExport">Export</button>
              <button id="presetImport">Import</button>
              <button id="presetSetDefault">Set as Default</button>
            </div>
          </div>
      <!-- Audio Preview Bar -->
      <div id="previewBar" style="margin:16px 0;display:flex;align-items:center;gap:8px;">
        <audio id="audioPreview" controls style="max-width:300px;"></audio>
        <button id="previewIn">Preview Input</button>
        <button id="previewOut">Preview Output</button>
      </div>

      <!-- Logs Dialog -->
      <button id="showLogsBtn">Show logs</button>
      <dialog id="logsDlg" style="width:70vw; max-width:900px;">
        <h3>Logs</h3>
        <textarea id="logsArea" style="width:100%; height:50vh" readonly></textarea>
        <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:8px;">
          <button id="copyLogsBtn">Copy</button>
          <button id="clearLogsBtn">Clear</button>
          <button id="closeLogsBtn">Close</button>
        </div>
      </dialog>

      <!-- Global Output Format -->
      <div style="margin:12px 0;">
        <label for="outputFormat">Output format</label>
        <select id="outputFormat">
          <option value="mp3">MP3</option>
          <option value="aac">AAC (m4a)</option>
          <option value="ogg">OGG Vorbis</option>
          <option value="flac">FLAC</option>
        </select>
      </div>
        </details>
      </div>

  <div class="card">
  <div style="display:flex; align-items:center; gap:8px; margin-bottom:8px">
          <label class="small">Resume queue on next launch</label>
          <input type="checkbox" id="resumeToggle" checked />
          <button class="btn secondary" id="resumeClear">Clear queue</button>
          <div id="resumeInfo" class="small"></div>
        </div>
  <div id="progressList"></div>
      <!-- Advanced Convert Button and Output Preview -->
      <div class="card advanced" style="margin-top:16px">
        <div class="row-inline">
          <button class="btn" id="startAdvanced" title="Convert using advanced options">Convert (Advanced)</button>
          <button class="btn secondary" id="previewOutput" title="Preview output file names before converting">Preview Output</button>
        </div>
        <div id="outputPreview" class="small" style="margin-top:8px;white-space:pre-wrap;"></div>
      </div>
      </div>

    </div>
    <script>
      const $ = (s)=>document.querySelector(s);
      const files = [];
      const list = $('#files');
      const progressList = $('#progressList');
      const logs = [];

      // Toasts
      const toaster = document.createElement('div');
      toaster.style.position='fixed'; toaster.style.bottom='20px'; toaster.style.right='20px'; toaster.style.zIndex='9999';
      document.body.appendChild(toaster);
      function toast(msg) {
        const div = document.createElement('div');
        div.textContent = msg;
        div.style.background = '#fffbe6'; // light yellow for visibility
        div.style.color = '#222'; // dark text for contrast
        div.style.border = '1.5px solid #ffd600';
        div.style.padding = '8px 12px';
        div.style.borderRadius = '8px';
        div.style.marginTop = '8px';
        div.style.boxShadow = '0 2px 8px #ffd60033';
        div.style.fontWeight = '600';
        toaster.appendChild(div);
        setTimeout(() => div.remove(), 3000);
      }

  function updateFiles() {
    const cnt = files.length;
    $('#filesCount').textContent = cnt + ' file' + (cnt!==1?'s':'');
    list.innerHTML = files.map((f, i) => (
      `<div class="file item" data-index="${i}" data-path="${f.replace(/"/g, '&quot;')}">
         <span class="filename">${f}</span>
         <button class="small-btn remove-btn" data-index="${i}" aria-label="Remove file">&times;</button>
         <button class="small-btn up-btn" data-index="${i}" aria-label="Move up">↑</button>
         <button class="small-btn down-btn" data-index="${i}" aria-label="Move down">↓</button>
       </div>`
    )).join('');
  }

  // Delegated click handler for queue management and preview
  list.addEventListener('click', (e) => {
    const idx = Number(e.target.dataset.index);
    if (e.target.classList.contains('remove-btn')) {
      files.splice(idx, 1);
      updateFiles();
      return;
    }
    if (e.target.classList.contains('up-btn')) {
      if (idx > 0) [files[idx-1], files[idx]] = [files[idx], files[idx-1]];
      updateFiles();
      return;
    }
    if (e.target.classList.contains('down-btn')) {
      if (idx < files.length-1) [files[idx], files[idx+1]] = [files[idx+1], files[idx]];
      updateFiles();
      return;
    }
    // Clicking a file item: preview input audio
    const item = e.target.closest('.item');
    if (item) {
      previewFile(item.getAttribute('data-path'));
    }
  });

  // Audio preview logic
  const audioPlayer = document.getElementById('audioPreview');
  function previewFile(filePath) {
    if (!filePath) return;
    let url = filePath;
    if (/^[A-Za-z]:\\/.test(filePath)) {
      url = 'file:///' + filePath.replace(/\\/g, '/');
    } else if (!filePath.startsWith('file://')) {
      url = 'file://' + filePath;
    }
    audioPlayer.src = url;
    audioPlayer.style.display = 'block';
    audioPlayer.play().catch(err => console.error('Audio preview error:', err));
  }

  // Click handler for progressList to preview output or input
  progressList.addEventListener('click', (e) => {
    const card = e.target.closest('.card');
    if (!card) return;
    if (e.target.tagName.toLowerCase() === 'progress' || e.target.classList.contains('error-detail')) return;
    const outPath = card.dataset.output;
    const inPath = card.querySelector('.file')?.textContent;
    const pathToPlay = outPath || inPath;
    previewFile(pathToPlay);
  });

      // Mode & Theme
  // Theme switching removed; will use static color scheme matching logo
      const modeSel = document.getElementById('modeSel');
      function applyMode(v){ document.body.setAttribute('data-mode', v); }
      const savedMode = localStorage.getItem('mode')||'simple'; modeSel.value = savedMode; applyMode(savedMode);
      modeSel.addEventListener('change', (e)=>{ const v = e.target.value; localStorage.setItem('mode', v); applyMode(v); });

      // Drag-and-drop (with folder expansion, ARIA, and keyboard accessibility)
      const dropZone = document.getElementById('dropZone');
      ;['dragenter','dragover'].forEach(evt => dropZone.addEventListener(evt, (e)=>{
        e.preventDefault();
        dropZone.style.background='#111827';
        dropZone.style.borderColor='#ffd600';
      }));
      ;['dragleave','drop'].forEach(evt => dropZone.addEventListener(evt, (e)=>{
        e.preventDefault();
        dropZone.style.background='';
        dropZone.style.borderColor='#888';
      }));
      dropZone.addEventListener('drop', async (e) => {
        e.preventDefault();
        dropZone.style.background = '';
        dropZone.style.borderColor = '#888';
        const paths = [...(e.dataTransfer?.files || [])].map(f => decodeURIComponent(f.path || f.name));
        if (paths.length) {
          console.log('Dropped paths:', paths);
          const expanded = window.vid2mp3?.fs?.expandPaths ? await window.vid2mp3.fs.expandPaths(paths) : paths;
          files.splice(0, files.length, ...(expanded || []));
          updateFiles();
        }
      });
      // ARIA & keyboard accessibility for drop zone
      dropZone.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          document.getElementById('pickFiles').click();
        }
      });
      // Output Folder Open
      document.getElementById('openOutBtn').addEventListener('click', async () => {
        const outDir = $('#outDir').value;
        if (window.vid2mp3?.openOutputFolder && outDir) {
          await window.vid2mp3.openOutputFolder(outDir);
        } else {
          toast('Output folder open not supported.');
        }
      });

      // Pause/Resume toggle button and ETA
      const pauseBtn = document.getElementById('pauseBtn');
      let totalCount = 0, startTime = 0;
      const progressPercents = [], inputIndexMap = {};
      pauseBtn.addEventListener('click', async () => {
        if (pauseBtn.textContent === 'Pause') {
          await window.vid2mp3.queue.pause();
          pauseBtn.textContent = 'Resume';
        } else {
          await window.vid2mp3.queue.resume();
          pauseBtn.textContent = 'Pause';
        }
      });
      // Progress/ETA logic (update onProgress handler)
      (window.vid2mp3?.onProgress||function(){})((evt) => {
        if (evt.type === 'start') {
          if (!totalCount) {
            totalCount = evt.total || files.length;
            startTime = Date.now();
            progressPercents.length = 0;
            for (let i = 0; i < totalCount; i++) progressPercents.push(0);
          }
          inputIndexMap[evt.input] = evt.index ?? files.indexOf(evt.input);
          ensureRow(evt.input).querySelector('progress').value = 0;
          document.getElementById('summary').textContent = 'Working…';
          pauseBtn.style.display = 'inline-block';
          pauseBtn.textContent = 'Pause';
        } else if (evt.type === 'progress') {
          const idx = inputIndexMap[evt.input];
          if (idx != null) progressPercents[idx] = Math.round(evt.percent || 0);
          const fraction = progressPercents.reduce((a,b) => a + b, 0) / (100 * totalCount);
          window.vid2mp3.sys.setProgress && window.vid2mp3.sys.setProgress(fraction);
          if (fraction > 0) {
            const elapsed = (Date.now() - startTime) / 1000;
            const remaining = elapsed * (1 - fraction) / fraction;
            const sec = Math.max(0, Math.round(remaining));
            const m = Math.floor(sec/60), s = sec % 60;
            const eta = m > 0 ? `${m}m ${s}s` : `${s}s`;
            document.getElementById('summary').textContent = `Working… (ETA: ~${eta} left)`;
          }
          const row = ensureRow(evt.input);
          row.querySelector('progress').value = Math.round(evt.percent || 0);
          row.querySelector('.status').textContent = Math.round(evt.percent || 0) + '%';
        } else if (evt.type === 'done') {
          const idx = inputIndexMap[evt.input];
          if (idx != null) progressPercents[idx] = 100;
          const row = ensureRow(evt.input);
          row.querySelector('progress').value = evt.ok ? 100 : 0;
          row.querySelector('.status').textContent = evt.ok ? 'Done' : 'Failed';
          if (!evt.ok) {
            row.querySelector('.error-detail').textContent = (evt.error || '') + (evt.stderr ? '\n' + evt.stderr : '');
            row.querySelector('.error-detail').style.display = 'block';
          }
        }
      });

      // Preset Import/Export/Set Default
      document.getElementById('presetExport').addEventListener('click', async () => {
        const name = document.getElementById('presetSelect').value;
        if (!name) return toast('Select a preset to export');
        try {
          await window.vid2mp3.presets.export(name);
          toast('Preset exported');
        } catch {
          toast('Failed to export preset');
        }
      });
      document.getElementById('presetImport').addEventListener('click', async () => {
        try {
          const result = await window.vid2mp3.presets.import();
          if (result && result.name) {
            toast(`Imported preset "${result.name}"`);
            updatePresetList();
          }
        } catch {
          toast('Failed to import preset');
        }
      });
      document.getElementById('presetSetDefault').addEventListener('click', async () => {
        const select = document.getElementById('presetSelect');
        const name = select.value;
        if (!name) return toast('Select a preset');
        if (window.vid2mp3?.presets?.setDefault) {
          try {
            await window.vid2mp3.presets.setDefault(name);
            toast('Default preset set');
          } catch {
            toast('Failed to set default preset');
          }
        }
      });

      // Audio Preview (Preview Input/Output)
      document.getElementById('previewIn').addEventListener('click', async () => {
        if (!files.length) return toast('Select a file first');
        const file = files[0];
        if (window.vid2mp3?.audioPreview) {
          try {
            const url = await window.vid2mp3.audioPreview(file, 'input');
            const audio = document.getElementById('audioPreview');
            audio.src = url;
            audio.play();
          } catch {
            toast('Failed to preview input audio');
          }
        }
      });
      document.getElementById('previewOut').addEventListener('click', async () => {
        if (!files.length) return toast('Select a file first');
        const file = files[0];
        if (window.vid2mp3?.audioPreview) {
          try {
            const url = await window.vid2mp3.audioPreview(file, 'output');
            const audio = document.getElementById('audioPreview');
            audio.src = url;
            audio.play();
          } catch {
            toast('Failed to preview output audio');
          }
        }
      });

      // Logs Dialog
      document.getElementById('showLogsBtn').addEventListener('click', async () => {
        const dlg = document.getElementById('logsDlg');
        dlg.showModal();
        if (window.vid2mp3?.logs?.get) {
          try {
            const logText = await window.vid2mp3.logs.get();
            document.getElementById('logsArea').value = logText;
          } catch {
            document.getElementById('logsArea').value = 'Failed to load logs';
          }
        }
      });
      document.getElementById('closeLogsBtn').addEventListener('click', () => {
        document.getElementById('logsDlg').close();
      });
      document.getElementById('copyLogsBtn').addEventListener('click', () => {
        const area = document.getElementById('logsArea');
        area.select();
        document.execCommand('copy');
        toast('Logs copied');
      });
      document.getElementById('clearLogsBtn').addEventListener('click', async () => {
        if (window.vid2mp3?.logs?.clear) {
          try {
            await window.vid2mp3.logs.clear();
            document.getElementById('logsArea').value = '';
            toast('Logs cleared');
          } catch {
            toast('Failed to clear logs');
          }
        }
      });

      // File selection (normalize Unicode paths)
      document.getElementById('pickFiles').addEventListener('click', async () => {
        const picked = window.vid2mp3?.selectFiles ? await window.vid2mp3.selectFiles() : await new Promise(resolve=>{ const inp = document.createElement('input'); inp.type='file'; inp.multiple=true; inp.accept='video/*'; inp.onchange = ()=>{ const filesList = Array.from(inp.files||[]); const paths = filesList.map(f=>f.path||f.name); resolve(paths); }; inp.click(); });
        if (picked && picked.length) {
          // Log raw file paths for debugging
          console.log('[TuneFlip Renderer] Raw picked paths:', picked);
          const norm = picked.map(p => {
            try {
              return decodeURIComponent(p);
            } catch { return p; }
          });
          files.splice(0, files.length, ...norm);
          updateFiles();
        }
      });

      // Out dir
      document.getElementById('pickOut').addEventListener('click', async () => {
        const dir = window.vid2mp3?.selectFolder ? await window.vid2mp3.selectFolder() : await new Promise(resolve=>{ const inp = document.createElement('input'); inp.type='file'; inp.setAttribute('webkitdirectory',''); inp.setAttribute('directory',''); inp.onchange = ()=>{ const filesList = Array.from(inp.files||[]); const first = filesList[0]; let out = ''; if (first && first.webkitRelativePath) { const wrp = first.webkitRelativePath; const idx = wrp.indexOf('/'); out = idx>0 ? wrp.slice(0, idx) : wrp; } resolve(out); }; inp.click(); });
        if (dir) $('#outDir').value = dir;
      });
      // Open Output Folder button
      document.getElementById('openOutDir').addEventListener('click', () => {
        const outDirPath = document.getElementById('outDir').value;
        if (outDirPath && window.vid2mp3?.os?.openPath) {
          window.vid2mp3.os.openPath(outDirPath);
        }
      });

      // Progress rows
      const fileProgress = new Map();
      function ensureRow(input) {
        if (fileProgress.has(input)) return fileProgress.get(input);
        const row = document.createElement('div');
        row.className = 'card';
        row.innerHTML = `<div class="file">${input}</div><progress max="100" value="0"></progress><div class="file status small"></div><pre class="error-detail" style="display:none;white-space:pre-wrap;background:#fffbe6;color:#b36b00;font-size:12px;padding:8px 0 0 0;margin:0"></pre>`;
        progressList.appendChild(row);
        fileProgress.set(input, row);
        return row;
      }

      // IPC progress (if available)
      (window.vid2mp3?.onProgress||function(){ return; })((evt) => {
        if (evt.type === 'start') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = 0;
          r.querySelector('.status').textContent = 'Starting…';
        } else if (evt.type === 'progress') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = Math.round(evt.percent||0);
          r.querySelector('.status').textContent = Math.round(evt.percent||0) + '%';
        } else if (evt.type === 'done') {
          const r = ensureRow(evt.input);
          r.querySelector('progress').value = evt.ok ? 100 : 0;
          if (evt.ok) {
            r.querySelector('.status').textContent = 'Done';
            r.querySelector('.error-detail').style.display = 'none';
          } else {
            r.querySelector('.status').textContent = 'Failed';
            // Show detailed error if available
            let detail = evt.error || '';
            if (evt.stderr) detail += '\n' + evt.stderr;
            r.querySelector('.error-detail').textContent = detail.trim();
            r.querySelector('.error-detail').style.display = 'block';
          }
        }
        logs.push(evt);
      });

      // Quality presets
      const qualitySel = document.getElementById('quality');
      qualitySel.addEventListener('change', ()=>{ const v = qualitySel.value; if (v==='std') { $('#bitrate').value=192; $('#vbr').value=''; } else if (v==='high') { $('#bitrate').value=256; $('#vbr').value=''; } else if (v==='vbr2') { $('#bitrate').value=''; $('#vbr').value=2; } });

      // Settings helpers
      async function loadSettingsIntoUI() {
        console.log('[TuneFlip Debug] Calling settings.get');
        const s = await (window.vid2mp3?.settings?.get?.() || Promise.resolve({}));
        console.log('[TuneFlip Debug] settings.get result:', s);
        if (s.outDir !== undefined) $('#outDir').value = s.outDir;
        if (s.quality !== undefined) $('#quality').value = s.quality;
        if (s.simpleConcurrency !== undefined) $('#simpleConcurrency').value = s.simpleConcurrency;
        if (s.throttle !== undefined) $('#throttle').value = s.throttle;
        if (s.trim !== undefined) $('#trim').value = s.trim;
        // Advanced (map backend fields to UI fields)
        if (s.bitrateKbps !== undefined) $('#bitrate').value = s.bitrateKbps;
        if (s.vbrLevel !== undefined) $('#vbr').value = s.vbrLevel;
        if (s.sampleRate !== undefined) $('#samplerate').value = s.sampleRate;
        if (s.channels !== undefined) $('#channels').value = s.channels;
        if (s.concurrency !== undefined) $('#concurrency').value = s.concurrency;
        if (s.retry && s.retry.attempts !== undefined) $('#retryAttempts').value = s.retry.attempts;
        if (s.retry && s.retry.delayMs !== undefined) $('#retryDelay').value = s.retry.delayMs;
        if (s.retryAttempts !== undefined) $('#retryAttempts').value = s.retryAttempts;
        if (s.retryDelay !== undefined) $('#retryDelay').value = s.retryDelay;
        if (s.loudnorm !== undefined) $('#loudnorm').checked = !!s.loudnorm;
        if (s.keepStructure !== undefined) $('#keepStructure').checked = !!s.keepStructure;
        if (s.overwrite !== undefined) $('#overwrite').checked = !!s.overwrite;
        if (s.dryRun !== undefined) $('#dryRun').checked = !!s.dryRun;
        if (s.template !== undefined) $('#template').value = s.template;
        if (s.autoMeta !== undefined) $('#autoMeta').checked = !!s.autoMeta;
        if (s.preferDetected !== undefined) $('#preferDetected').checked = !!s.preferDetected;
        if (s.autoCoverEnabled !== undefined) $('#autoCoverEnabled').checked = !!s.autoCoverEnabled;
        if (s.autoCoverTime !== undefined) $('#autoCoverTime').value = s.autoCoverTime;
        if (s.coverFrameSec !== undefined) $('#coverFrameSec').value = s.coverFrameSec;
        if (Array.isArray(s.coverFrameRules)) {
          const lines = s.coverFrameRules.map(r=>`${r.pattern} => ${r.timeSec}`).join('\n');
          document.getElementById('coverFrameRules').value = lines;
        }
  if (s.id3Title !== undefined) $('#id3Title').value = s.id3Title;
  if (s.id3Artist !== undefined) $('#id3Artist').value = s.id3Artist;
  if (s.id3Album !== undefined) $('#id3Album').value = s.id3Album;
  if (s.id3Genre !== undefined) $('#id3Genre').value = s.id3Genre;
  if (s.id3Date !== undefined) $('#id3Date').value = s.id3Date;
  if (s.id3Track !== undefined) $('#id3Track').value = s.id3Track;
  if (s.id3Comment !== undefined) $('#id3Comment').value = s.id3Comment;
  if (s.id3Composer !== undefined) $('#id3Composer').value = s.id3Composer;
  if (s.id3Disc !== undefined) $('#id3Disc').value = s.id3Disc;
  if (s.coverPath !== undefined) $('#coverPath').value = s.coverPath;
      }
      async function saveSettingsFromUI() {
        const data = {
          outDir: $('#outDir').value,
          quality: $('#quality').value,
          simpleConcurrency: parseInt($('#simpleConcurrency').value)||4,
          throttle: $('#throttle').value,
          trim: $('#trim').value || '',
          bitrateKbps: parseInt($('#bitrate')?.value)||undefined,
          vbrLevel: parseInt($('#vbr')?.value)||undefined,
          sampleRate: parseInt($('#samplerate')?.value)||undefined,
          channels: parseInt($('#channels')?.value)||undefined,
          concurrency: parseInt($('#concurrency')?.value)||4,
          retry: {
            attempts: parseInt($('#retryAttempts')?.value)||1,
            delayMs: parseInt($('#retryDelay')?.value)||0
          },
          retryAttempts: parseInt($('#retryAttempts')?.value)||'',
          retryDelay: parseInt($('#retryDelay')?.value)||'',
          loudnorm: !!document.getElementById('loudnorm')?.checked,
          keepStructure: !!document.getElementById('keepStructure')?.checked,
          overwrite: !!document.getElementById('overwrite')?.checked,
          dryRun: !!document.getElementById('dryRun')?.checked,
          autoMeta: !!document.getElementById('autoMeta')?.checked,
          preferDetected: !!document.getElementById('preferDetected')?.checked,
          template: $('#template')?.value||'',
          autoCoverEnabled: !!document.getElementById('autoCoverEnabled')?.checked,
          autoCoverTime: parseInt($('#autoCoverTime')?.value)||undefined,
          coverFrameSec: parseInt($('#coverFrameSec')?.value)||undefined,
          coverFrameRules: (document.getElementById('coverFrameRules')?.value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          id3Title: $('#id3Title')?.value||'',
          id3Artist: $('#id3Artist')?.value||'',
          id3Album: $('#id3Album')?.value||'',
          id3Genre: $('#id3Genre')?.value||'',
          id3Date: $('#id3Date')?.value||'',
          id3Track: $('#id3Track')?.value||'',
          id3Comment: $('#id3Comment')?.value||'',
          id3Composer: $('#id3Composer')?.value||'',
          id3Disc: $('#id3Disc')?.value||'',
          coverPath: $('#coverPath')?.value||'',
        };
        console.log('[TuneFlip Debug] Calling settings.save with:', data);
        await (window.vid2mp3?.settings?.save?.(data) || Promise.resolve(true));
        await loadSettingsIntoUI(); // reload UI after save
      }
      document.getElementById('saveSettings').addEventListener('click', async () => {
        try {
          await saveSettingsFromUI();
          toast('Settings saved');
        } catch (e) {
          console.error('[TuneFlip Debug] Save settings error:', e);
          toast('Failed to save settings');
        }
      });
      document.getElementById('loadSettings').addEventListener('click', async () => {
        try {
          await loadSettingsIntoUI();
          toast('Settings loaded');
        } catch (e) {
          console.error('[TuneFlip Debug] Load settings error:', e);
          toast('Failed to load settings');
        }
      });

      // --- Preset Management ---
      async function updatePresetList() {
        const presets = await (window.vid2mp3?.presets?.list?.() || Promise.resolve({}));
        const select = document.getElementById('presetSelect');
        select.innerHTML = '';
        for (const name in presets) {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name;
          select.appendChild(opt);
        }
      }

      document.getElementById('savePreset').addEventListener('click', async () => {
        const name = document.getElementById('presetName').value.trim();
        if (!name) return toast('Please enter a preset name');
        // Gather current settings into an options object:
        const options = await (window.vid2mp3?.settings?.get?.() || Promise.resolve({}));
        try {
          await window.vid2mp3.presets.save(name, options);
          toast(`Preset "${name}" saved`);
          updatePresetList();
        } catch {
          toast('Failed to save preset');
        }
      });

      document.getElementById('loadPreset').addEventListener('click', async () => {
        const select = document.getElementById('presetSelect');
        const name = select.value;
        if (!name) return toast('Please select a preset');
        try {
          const allPresets = await window.vid2mp3.presets.list();
          const presetOptions = allPresets[name];
          if (presetOptions) {
            // Apply each option to the corresponding field (reusing loadSettingsIntoUI logic):
            if (presetOptions.outDir) $('#outDir').value = presetOptions.outDir;
            if (presetOptions.quality) $('#quality').value = presetOptions.quality;
            if (presetOptions.bitrateKbps) $('#bitrate').value = presetOptions.bitrateKbps;
            if (presetOptions.vbrLevel) $('#vbr').value = presetOptions.vbrLevel;
            if (presetOptions.sampleRate) $('#samplerate').value = presetOptions.sampleRate;
            if (presetOptions.channels) $('#channels').value = presetOptions.channels;
            if (presetOptions.concurrency) $('#concurrency').value = presetOptions.concurrency;
            if (presetOptions.retry && presetOptions.retry.attempts !== undefined) $('#retryAttempts').value = presetOptions.retry.attempts;
            if (presetOptions.retry && presetOptions.retry.delayMs !== undefined) $('#retryDelay').value = presetOptions.retry.delayMs;
            if (presetOptions.loudnorm !== undefined) $('#loudnorm').checked = !!presetOptions.loudnorm;
            if (presetOptions.keepStructure !== undefined) $('#keepStructure').checked = !!presetOptions.keepStructure;
            if (presetOptions.overwrite !== undefined) $('#overwrite').checked = !!presetOptions.overwrite;
            if (presetOptions.dryRun !== undefined) $('#dryRun').checked = !!presetOptions.dryRun;
            if (presetOptions.template) $('#template').value = presetOptions.template;
            if (presetOptions.autoMeta !== undefined) $('#autoMeta').checked = !!presetOptions.autoMeta;
            if (presetOptions.preferDetected !== undefined) $('#preferDetected').checked = !!presetOptions.preferDetected;
            if (presetOptions.autoCoverEnabled !== undefined) $('#autoCoverEnabled').checked = !!presetOptions.autoCoverEnabled;
            if (presetOptions.autoCoverTime !== undefined) $('#autoCoverTime').value = presetOptions.autoCoverTime;
            if (presetOptions.coverFrameSec !== undefined) $('#coverFrameSec').value = presetOptions.coverFrameSec;
            if (Array.isArray(presetOptions.coverFrameRules)) {
              const lines = presetOptions.coverFrameRules.map(r=>`${r.pattern} => ${r.timeSec}`).join('\n');
              document.getElementById('coverFrameRules').value = lines;
            }
            if (presetOptions.id3Title !== undefined) $('#id3Title').value = presetOptions.id3Title;
            if (presetOptions.id3Artist !== undefined) $('#id3Artist').value = presetOptions.id3Artist;
            if (presetOptions.id3Album !== undefined) $('#id3Album').value = presetOptions.id3Album;
            if (presetOptions.id3Genre !== undefined) $('#id3Genre').value = presetOptions.id3Genre;
            if (presetOptions.id3Date !== undefined) $('#id3Date').value = presetOptions.id3Date;
            if (presetOptions.id3Track !== undefined) $('#id3Track').value = presetOptions.id3Track;
            if (presetOptions.id3Comment !== undefined) $('#id3Comment').value = presetOptions.id3Comment;
            if (presetOptions.id3Composer !== undefined) $('#id3Composer').value = presetOptions.id3Composer;
            if (presetOptions.id3Disc !== undefined) $('#id3Disc').value = presetOptions.id3Disc;
            if (presetOptions.coverPath !== undefined) $('#coverPath').value = presetOptions.coverPath;
            toast(`Preset "${name}" loaded`);
          }
        } catch {
          toast('Failed to load preset');
        }
      });

      document.getElementById('deletePreset').addEventListener('click', async () => {
        const select = document.getElementById('presetSelect');
        const name = select.value;
        if (!name) return;
        if (!confirm(`Delete preset "${name}"?`)) return;
        try {
          await window.vid2mp3.presets.delete(name);
          toast(`Preset "${name}" deleted`);
          updatePresetList();
        } catch {
          toast('Failed to delete preset');
        }
      });

      // Auto-load on startup
      loadSettingsIntoUI();
      updatePresetList().then(async () => {
        if (window.vid2mp3?.presets?.getDefault) {
          const defaultName = await window.vid2mp3.presets.getDefault();
          const allPresets = await window.vid2mp3.presets.list();
          if (defaultName && allPresets && defaultName in allPresets) {
            document.getElementById('presetSelect').value = defaultName;
            document.getElementById('loadPreset').click();
          }
        }
      });

      // Resume controls
      async function refreshResumeUI() {
        try {
          const r = await (window.vid2mp3?.resume?.get?.() || Promise.resolve({ enabled: true, queue: { pending: [], done: [], fail: [] }}));
          document.getElementById('resumeToggle').checked = !!r.enabled;
          const q = r.queue||{pending:[],done:[],fail:[]};
          document.getElementById('resumeInfo').textContent = `Queue: ${q.pending.length} pending, ${q.done.length} done, ${q.fail.length} failed`;
        } catch {}
      }
      document.getElementById('resumeToggle').addEventListener('change', async (e)=>{
        try { await (window.vid2mp3?.resume?.set?.(e.target.checked) || Promise.resolve(true)); refreshResumeUI(); } catch {}
      });
      document.getElementById('resumeClear').addEventListener('click', async ()=>{
        try {
          await (window.vid2mp3?.resume?.clear?.() || Promise.resolve(true));
          // Clear progress list and fileProgress map
          progressList.innerHTML = '';
          fileProgress.clear();
          refreshResumeUI();
          toast('Queue cleared');
        } catch {}
      });
      refreshResumeUI();


      // Helper to collect all advanced options from UI
      function getAdvancedOptions() {
        return {
          bitrateKbps: parseInt($('#bitrate')?.value) || undefined,
          vbrLevel: parseInt($('#vbr')?.value) || undefined,
          sampleRate: parseInt($('#samplerate')?.value) || undefined,
          channels: parseInt($('#channels')?.value) || undefined,
          loudnorm: !!document.getElementById('loudnorm')?.checked,
          keepStructure: !!document.getElementById('keepStructure')?.checked,
          overwrite: !!document.getElementById('overwrite')?.checked,
          concurrency: parseInt($('#concurrency')?.value) || 4,
          throttle: $('#throttle').value,
          autoMeta: !!document.getElementById('autoMeta')?.checked,
          preferDetected: !!document.getElementById('preferDetected')?.checked,
          template: $('#template')?.value || '{basename}.mp3',
          autoCover: !!document.getElementById('autoCoverEnabled')?.checked,
          autoCoverTime: parseInt($('#autoCoverTime')?.value) || undefined,
          coverFrameSec: parseFloat(document.getElementById('coverFrameSec')?.value) || undefined,
          coverFrameRules: (document.getElementById('coverFrameRules')?.value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          metadata: {
            title: $('#id3Title')?.value || '',
            artist: $('#id3Artist')?.value || '',
            album: $('#id3Album')?.value || '',
            genre: $('#id3Genre')?.value || '',
            date: $('#id3Date')?.value || '',
            track: $('#id3Track')?.value || '',
            comment: $('#id3Comment')?.value || '',
            coverImagePath: $('#coverPath')?.value || ''
          },
          retry: {
            attempts: parseInt($('#retryAttempts')?.value) || 1,
            delayMs: parseInt($('#retryDelay')?.value) || 0
          }
        };
      }

      // Utility: Check if a file has an audio stream using ffprobe
      async function hasAudioStream(filePath) {
        // Use ffprobe-static and Node.js child_process via a backend IPC if needed
        // For now, try conversion and catch the error, or implement a backend IPC for ffprobe
        // Here, we just skip files that previously failed with 'matches no streams'
        // (A real implementation would use a backend IPC to ffprobe)
        return true; // Placeholder: always true, see backend for real check
      }

      // Patch: Filter out files with no audio stream before conversion (frontend warning only)
      async function filterFilesWithAudio(files) {
        // In a real implementation, call a backend IPC to ffprobe each file
        // For now, just return all files (since we can't run ffprobe in browser)
        // You can implement a backend handler for this if needed
        return files;
      }


      // Simple Convert button
      document.getElementById('start').addEventListener('click', async () => {
        if (!files.length) { alert('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        const mode = document.getElementById('modeSel').value;
        const concurrency = mode === 'advanced'
          ? parseInt($('#concurrency').value) || 4
          : parseInt($('#simpleConcurrency').value) || 4;
        const outputFormat = document.getElementById('outputFormat').value;
        const options = {
          bitrateKbps: parseInt($('#bitrate').value) || undefined,
          vbrLevel: parseInt($('#vbr').value) || undefined,
          sampleRate: parseInt($('#samplerate').value) || undefined,
          channels: parseInt($('#channels').value) || undefined,
          trim: $('#trim').value || undefined,
          loudnorm: !!$('#loudnorm').checked,
          keepStructure: !!$('#keepStructure').checked,
          overwrite: !!$('#overwrite').checked,
          concurrency: concurrency,
          throttle: $('#throttle').value,
          autoMeta: !!$('#autoMeta').checked,
          preferDetected: !!$('#preferDetected').checked,
          template: $('#template').value || undefined,
          autoCover: { enabled: !!$('#autoCoverEnabled').checked, timeSec: parseInt($('#autoCoverTime').value) || undefined },
          coverFrameSec: parseFloat($('#coverFrameSec').value) || undefined,
          coverFrameRules: ($('#coverFrameRules').value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          metadata: {
            title: $('#id3Title').value || undefined,
            artist: $('#id3Artist').value || undefined,
            album: $('#id3Album').value || undefined,
            genre: $('#id3Genre').value || undefined,
            date: $('#id3Date').value || undefined,
            track: $('#id3Track').value || undefined,
            comment: $('#id3Comment').value || undefined,
            composer: $('#id3Composer').value || undefined,
            disc: $('#id3Disc').value || undefined,
            coverImagePath: $('#coverPath').value || undefined
          },
          retry: { attempts: parseInt($('#retryAttempts').value) || 1, delayMs: parseInt($('#retryDelay').value) || 0 },
          format: document.getElementById('format')?.value || 'mp3'
        };
        // Filter files with audio stream (placeholder, see above)
        const filesWithAudio = await filterFilesWithAudio(files);
        if (!filesWithAudio.length) {
          toast('No files with audio streams found.');
          return;
        }
        document.getElementById('summary').textContent = 'Working…';
        try {
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: true, text: 'Converting...', tooltip: 'TuneFlip – Converting files' });
          const { results } = await window.vid2mp3.startConvert({ inputs: filesWithAudio, outDir, options });
          const ok = results.filter(r=>r.ok).length; const fail = results.length - ok;
          if (fail > 0) {
            document.getElementById('summary').textContent = `Done: ${ok} ok, ${fail} failed`;
          } else {
            document.getElementById('summary').textContent = `Done: ${ok} ok, 0 failed`;
          }
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: false });
          window.vid2mp3.sys.notify && window.vid2mp3.sys.notify({
            title: 'TuneFlip – Batch Complete',
            body: fail ? `${ok} files succeeded, ${fail} failed.` : `All ${ok} files converted successfully!`
          });
        } catch (e) {
          document.getElementById('summary').textContent = 'Failed'; toast('Failed to start: ' + (e && e.message || e));
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: false });
        }
      });

      // Advanced Convert button
      document.getElementById('startAdvanced').addEventListener('click', async () => {
        if (!files.length) { alert('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        const mode = document.getElementById('modeSel').value;
        const concurrency = mode === 'advanced'
          ? parseInt($('#concurrency').value) || 4
          : parseInt($('#simpleConcurrency').value) || 4;
        const options = {
          bitrateKbps: parseInt($('#bitrate').value) || undefined,
          vbrLevel: parseInt($('#vbr').value) || undefined,
          sampleRate: parseInt($('#samplerate').value) || undefined,
          channels: parseInt($('#channels').value) || undefined,
          trim: $('#trim').value || undefined,
          loudnorm: !!$('#loudnorm').checked,
          keepStructure: !!$('#keepStructure').checked,
          overwrite: !!$('#overwrite').checked,
          concurrency: concurrency,
          throttle: $('#throttle').value,
          autoMeta: !!$('#autoMeta').checked,
          preferDetected: !!$('#preferDetected').checked,
          template: $('#template').value || undefined,
          autoCover: { enabled: !!$('#autoCoverEnabled').checked, timeSec: parseInt($('#autoCoverTime').value) || undefined },
          coverFrameSec: parseFloat($('#coverFrameSec').value) || undefined,
          coverFrameRules: ($('#coverFrameRules').value||'').split(/\n+/).map(line=>{
            const m = line.match(/^\s*(.*?)\s*=>\s*(\d+(?:\.\d+)?)\s*$/);
            if (!m) return null;
            return { pattern: m[1], timeSec: parseFloat(m[2]) };
          }).filter(Boolean),
          metadata: {
            title: $('#id3Title').value || undefined,
            artist: $('#id3Artist').value || undefined,
            album: $('#id3Album').value || undefined,
            genre: $('#id3Genre').value || undefined,
            date: $('#id3Date').value || undefined,
            track: $('#id3Track').value || undefined,
            comment: $('#id3Comment').value || undefined,
            coverImagePath: $('#coverPath').value || undefined
          },
          retry: { attempts: parseInt($('#retryAttempts').value) || 1, delayMs: parseInt($('#retryDelay').value) || 0 },
          format: document.getElementById('formatAdv')?.value || 'mp3'
        };
        // Filter files with audio stream (placeholder, see above)
        const filesWithAudio = await filterFilesWithAudio(files);
        if (!filesWithAudio.length) {
          toast('No files with audio streams found.');
          return;
        }
        document.getElementById('summary').textContent = 'Working…';
        try {
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: true, text: 'Converting...', tooltip: 'TuneFlip – Converting files' });
          const { results } = await window.vid2mp3.startConvert({ inputs: filesWithAudio, outDir, options });
          const ok = results.filter(r=>r.ok).length; const fail = results.length - ok;
          if (fail > 0) {
            document.getElementById('summary').textContent = `Done: ${ok} ok, ${fail} failed`;
          } else {
            document.getElementById('summary').textContent = `Done: ${ok} ok, 0 failed`;
          }
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: false });
          window.vid2mp3.sys.notify && window.vid2mp3.sys.notify({
            title: 'TuneFlip – Batch Complete',
            body: fail ? `${ok} files succeeded, ${fail} failed.` : `All ${ok} files converted successfully!`
          });
        } catch (e) {
          document.getElementById('summary').textContent = 'Failed'; toast('Failed to start: ' + (e && e.message || e));
          window.vid2mp3.sys.traySet && window.vid2mp3.sys.traySet({ visible: false });
        }
      });

      // Preview Output button
      document.getElementById('previewOutput').addEventListener('click', async () => {
        if (!files.length) { toast('Select files first'); return; }
        const outDir = $('#outDir').value || 'out';
        const options = getAdvancedOptions();
        console.log('[TuneFlip Debug] Calling previewOutput with:', { inputs: files, outDir, options });
        try {
          const preview = await (window.vid2mp3?.previewOutput?.({ inputs: files, outDir, options }) || Promise.resolve([]));
          console.log('[TuneFlip Debug] previewOutput result:', preview);
          document.getElementById('outputPreview').textContent = preview.join('\n');
        } catch (e) {
          console.error('[TuneFlip Debug] Preview output error:', e);
          document.getElementById('outputPreview').textContent = 'Failed to preview: ' + (e && e.message || e);
        }
      });

      // Auto-save on exit
      window.addEventListener('beforeunload', ()=>{ saveSettingsFromUI(); });

      // Diagnostics if preload missing
      if (!window.vid2mp3) { const d = document.getElementById('diag'); d.style.display='block'; d.textContent = 'Preload API not detected. Using fallback pickers.'; }
    </script>
  </body>
</html>
